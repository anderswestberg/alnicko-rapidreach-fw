# V0.0.1 vs Current Code - Detailed Comparison

## Critical Discovery

v0.0.1 **was NOT actually working either** - it had the same frame size mismatch bug!

### v0.0.1 Configuration Mismatch (Same as Current)
```
FFmpeg Encoder:  -ar 16000  (16 kHz encoding)
Kconfig Default: 48000 Hz   (48 kHz decoder config)
Result: 320-sample frames vs 960-sample expectations = FRAME MISMATCH
```

## Key Differences Between v0.0.1 and Current

### Difference 1: Memory Allocation (CRITICAL!)
**v0.0.1:**
```c
DecConfigOpus.pInternalMemory = malloc(dec_size * DUPLICATION_FACTOR);
// Always allocates 2× regardless of MONO/STEREO
```

**Current (Conditional):**
```c
#ifdef CONFIG_RPR_AUDIO_PLAYER_STEREO
    DecConfigOpus.pInternalMemory = malloc(dec_size * DUPLICATION_FACTOR);
#else
    DecConfigOpus.pInternalMemory = malloc(dec_size);
#endif
```

**The Problem:**
- v0.0.1: Always allocates 2× space (whether STEREO or MONO)
- With MONO (current config), only half the allocated space is used
- But duplicate_samples() still operates on the 2× allocated buffer
- This can lead to **unexpected memory layout issues**

### Difference 2: Sample Duplication (MAJOR!)
**v0.0.1:**
```c
int samples_remaining = duplicate_samples(pcm_ptr, decoded_samples);
// ALWAYS called, even in MONO mode
```

**Current (Conditional):**
```c
#ifdef CONFIG_RPR_AUDIO_PLAYER_STEREO
    samples_remaining = duplicate_samples(pcm_ptr, decoded_samples);
#else
    samples_remaining = decoded_samples;  // NO duplication
#endif
```

**The Critical Issue Here:**
In v0.0.1, with 16 kHz mono:
- Decoded: 320 samples
- After duplicate_samples(): 640 samples (stereo layout)
- I2S configured for MONO expects: 320 samples
- **This should cause white noise just like current code!**

Wait... unless v0.0.1 is also using 48 kHz hardware?

### Difference 3: Error Handling
**v0.0.1:**
```c
if (decoded_samples < 0) {
    LOG_ERR("Opus decoding error: %d", decoded_samples);
    return true;  // Bug: returns true on error
}
```

**Current (Fixed):**
```c
if (decoded_samples < 0) {
    LOG_ERR("Opus decoding error: %d", decoded_samples);
    return false;  // Correct: returns false on error
}
```

This is the ONLY real fix between versions for this function.

## The Real Question

**If v0.0.1 had:**
- 48 kHz Kconfig default
- 16 kHz FFmpeg encoding  
- Always-on sample duplication even for MONO
- Error handling returning true on error

...how could it possibly work?

### Hypothesis: The Hardware

The working v0.0.1 system might have been:
1. **Actually configured for 48 kHz hardware** (not MONO)
2. **The Kconfig was actually 48000 in the built version**
3. **FFmpeg 16 kHz was intentional downsample → upsample chain**

Let me check if there's a prebuild config file or if the hardware is actually 48 kHz...

## Analysis: Why Current Code Produces White Noise

With current config (16 kHz MONO):

```
1. Opus decodes 320 mono samples (16 kHz frame)
2. duplicate_samples() ← NOW SKIPPED (our fix!)
3. samples_remaining = 320
4. Copied to I2S buffer: 320 samples at 16 kHz
5. I2S transmits at 16 kHz mono
6. Should be CORRECT AUDIO now with our fix...
```

But you're still getting white noise. This suggests either:

**A) Hardware is actually 48 kHz output**
- I2S hardware expects 48 kHz frames
- Getting 16 kHz frames = underflow/corruption = noise

**B) The decoder is still corrupted**
- Frame size mismatch: 320 samples fed to 960-sample decoder
- Decoding garbage = white noise

**C) Memory allocation issue**
- With MONO malloc(dec_size), there's not enough space
- Data overflow happens during duplication in v0.0.1
- Or decoder thinks it has more buffer than it does

## The Real Problem: Encoder/Decoder Frame Size

Look at the math:

**Current Config (MONO, 16 kHz):**
```
SAMPLE_FREQUENCY = 16000
DECODER_MS_FRAME = 20
Decoded samples per frame = (16000/1000) × 20 = 320 samples ✓

DEC_frame_size calculation:
  = (16000/1000) × 20 = 320 samples ✓
  
Expected output from opus_decode() = 320 samples ✓
```

**BUT look at what FFmpeg encodes:**
- FFmpeg with `-ar 16000` encodes at 16 kHz
- Opus frame is still 20ms in the file
- So each Opus packet contains 20ms of 16 kHz audio = 320 samples ✓

This should MATCH! So why white noise?

## Hypothesis: The DEC_Opus_Decode() Contract

The issue might be in how `DEC_Opus_Decode()` works:

```c
int DEC_Opus_Decode(uint8_t *buf_in, uint32_t len, uint8_t *buf_out)
{
  return opus_decode(hOpus.Decoder, 
                    (unsigned char *) buf_in, 
                    (opus_int32) len, 
                    (opus_int16 *) buf_out, 
                    hOpus.DEC_frame_size,  // ← This is critical!
                    0);
}
```

**The DEC_frame_size parameter** tells opus_decode() how many samples to produce.

If:
- `hOpus.DEC_frame_size = 320` (from 16 kHz config)
- But the Opus packet was encoded with assumption of different frame size
- Then opus_decode() tries to decode into wrong-sized output
- Result: garbage = white noise

## Root Cause: Likely Packet Frame Size Mismatch

The **REAL issue** might be:

1. FFmpeg creates Opus packets with 16 kHz assumption
2. Device decoder configured to expect 16 kHz (320 samples)
3. But the **Opus header in the file** specifies something different
4. Example: Opus encoded at 48 kHz but downsampled to 16 kHz
5. Device tries to decode 48 kHz Opus into 16 kHz buffer = CORRUPTION

Check the code that reads the Opus header:

```c
OpusHeader header;
int parse_result = opus_header_parse(op->packet, op->bytes, &header);
LOG_INF("Opus header: sample_rate=%d, channels=%d",
        header.input_sample_rate,
        header.channels);
```

**What does the actual Opus file header say?**
- Is it 48000?
- Is it 16000?

This needs to be verified!

## Solution Options

### Option 1: Verify Actual Opus File Header
```bash
ffprobe -v error -select_streams a:0 -show_entries stream=sample_rate audio.opus
# Should output: 16000 (if our FFmpeg is correct)
# But might output: 48000 (if FFmpeg is wrong)
```

### Option 2: Force Exact Match in FFmpeg
Ensure FFmpeg generates 16 kHz Opus:
```bash
ffmpeg -i input.wav \
       -c:a libopus \
       -b:a 32k \
       -ar 16000 \
       -frame_duration 20 \   # Explicit 20ms frames
       output.opus
```

### Option 3: Revert to v0.0.1 Approach
But this doesn't make sense since v0.0.1 had the same mismatch...

## Key Question for Debugging

**Can you check what's in a freshly encoded audio file?**

```bash
# 1. Create a simple test file
ffmpeg -f lavfi -i "sine=f=440:r=16000:d=2" -c:a libopus test.opus

# 2. Check its properties
ffprobe -v error -select_streams a:0 -show_entries stream= test.opus

# 3. Check the Opus header bytes
hexdump -C test.opus | head
# Should see: "4f 67 67 53" (OggS) then Opus header

# 4. Upload to device and test
```

If this test file works, the issue is with how FFmpeg is encoding.
If it still doesn't work, the issue is in the device decoder config.

## Summary: What Changed That Broke It

The **conditional duplication** change might actually be the issue!

In v0.0.1: `duplicate_samples()` was **ALWAYS** called:
- 320 samples → 640 samples
- THEN: `samples_to_copy = MIN(SAMPLES_PER_BLOCK, 640)`
- With 48 kHz assumption: `SAMPLES_PER_BLOCK = 960`
- Result: copies MIN(960, 640) = 640 bytes
- Data is interleaved stereo: [L, R, L, R, ...]

But I2S is configured for **MONO** (1 channel):
- Expects: [mono_sample, mono_sample, ...]
- Gets: [L, R, L, R, ...] (interleaved stereo data)
- **Both v0.0.1 and current should produce white noise!**

Unless... v0.0.1 had different I2S configuration?

## Next Steps

1. **Check what the actual Opus file header says**
   - Device logs show header.input_sample_rate
   
2. **Verify FFmpeg output actually matches**
   - ffprobe the generated .opus file
   
3. **Check if v0.0.1 was actually running on device**
   - Maybe it was never flashed?
   - Or a different hardware configuration?

4. **Compare I2S configuration between versions**
   - Was I2S set to stereo in v0.0.1?
   - Was NUMBER_OF_CHANNELS different?
